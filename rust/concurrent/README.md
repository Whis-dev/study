# Concurrent

- 동시성 vs 병렬
  - 동시성 : 프로그램의 서로 다른 부분이 독립적으로 실행
  - 병렬 : 프로그램의 서로 다른 부분이 동시에 실행

> 소유권과 타입 검사를 지렛대 삼아, 많은 동시성 에러는 런타임 에러가 아닌 컴파일 타임 에러가 됨

- 이번 장의 포인트
  - 스레드를 생성하여 여러 조각의 코드를 동시에 실행
  - 채널들이 스레드 간에 메시지를 보내는 메시지 패싱 동시성
  - 여러 스레드가 어떤 동일한 데이터에 접근할 수 있는 공유 상태 동시성
  - 러스트의 동시성 보장을 표준 라이브러리가 제공하는 타입은 물론 사용자 정의 타입으로 확장하는 Sync와 Send 트레이트

## 스레드

- 프로그램 내의 연산을 여러 스레드로 쪼개서 동시에 여러일을 시키면 성능향상이 되나 복잡도가 올라감
- 스레드가 동시에 실행될 수 있어서 서로 다른 스레드에서 실행될 코드 조각들의 실행 순서에 대한 보장이 안됨
  - 여러 스레드가 일관성 없는 순서로 데이터 혹은 리소스에 접근하게 되는 경합조건(race condition)
  - 두 스레드가 서로를 기다려서 양쪽 스레드 모두 계속 실행되는 것을 막아버리는 교착상태(deadlock)
  - 특정한 상황에서만 발생하여 재현하고 수정하기 어려운 버그들
- 러스트는 스레드 구현에 대해 1:1 모델을 사용 -> 이에 따라 프로그램은 하나의 언어 스레드당 하나의 운영체제 스레드를 사용
  - 다른 절충안이 있는 그 밖의 스레드 모델을 구현한 크레이트도 있음
- 클로저가 외부의 벡터를 사용하면, 벡터는 캡처되어 클로저 환경의 일부가 됨. thread::spawn이 이 클로저를 새로운 스레드에서 실행하므로, 벡터는 새로운 스레드 내에서 접근 가능해야함.
  - 러스트는 벡터를 어떻게 캡쳐할지 추론하고, println!이 벡터의 참조자만 필요로 하기 때문에, 클로저는 벡터를 빌리려고 합 -> 러스트는 생성된 스레드가 얼마나 오랫동안 실행될지 알 수 없으므로 벡터에 대한 참조자가 항상 유효할 것인지 알 수 없음

## 메시지 패싱

> 안전한 동시성을 보장. 스레드들 혹은 액터들이 서로 데이터를 담은 메시지를 보내서 통신하는 것

- 메시지 보내기 동시성을 달성하기 위해서 러스트 표준 라이브러리는 채널 구현체를 제공 -> 채널 : 한 스레드에서 다른 쪽으로 데이터를 보내기 위한 일반적인 프로그래밍 개념
- 채널은 송신자와 수신자로 나뉨
- mpsc(multiple producer, single consumer) : 러스트 표준 라이브러리가 채널을 구현한 방법은 한 채널이 값을 생산하는 송신 단말을 여러 개 가질 수 있지만 값을 소비하는 수신 단말은 단 하나만 가질 수 있음

## 공유 상태 동시성

- 복수 소유권과 유사
- 뮤텍스(Mutex)
  - 상호 배제의 줄임말
  - 한 번에 하나의 스레드만 데이터 접근을 허용
  - 뮤텍스 내부의 데이터에 접근하려면 스레드는 먼저 뮤텍스의 락(lock)을 얻는 요청을 해서 접근을 희망하는 신호를 보내야함 -> 한 번에 하나의스레드만 데이터 접근을 허용해야하기 때문
  - 규칙
    - 데이터를 사용하기 전에는 반드시 락을 얻는 시도를 해야함
    - 만일 뮤텍스가 보호하는 데이터의 사용이 끝났다면, 반드시 언락을 해야 다른 스레드들이 락을 얻을 수 있음
  - Mutex 는 스마트 포인터
  - 내부 가변성 제공
  - 교착 상태를 생성할 위험성이 따라옴

## Send 트레이트

> 스레드와 함께 사용하는 타입들이 동시적 상황에서 쓰이기 위한 것임을 보장

- Arc : 동시적 상황에서 안전하게 사용할 수 있는 Rc 같은 타입. a는 atomic을 의미하는데 원자적으로 참조자를 세는(atomically reference counted)타입을 뜻함
  - 표준 라이브러리 타입이 기본적으로 arc를 사용하지 않는 것은 스레드 안전성이란 것이 정말로 필요할 때만 감내하고 싶을 성능 저하를 일으키기 때문. 예를 들어 싱글 스레드 내에서만 값을 연산하는 경우, 아토믹이 제공하는 보장을 강제할 필요 없이 코드는 더 빠르게 실행될 수 있음

## Send 마커 트레이트

- Send가 구현된 타입의 소유권이 스레드 사이에서 이동될 수 있음을 나타님
- 대부분의 러스트 타입이 Send이지만 몇개의 예외가 있음 -> Rc : Rc 값을 복제하여 다른 스레드로 복제본의 소유권 전송을 시도하면 두 스레드 모두 동시에 참조 카운트 값을 업데이트 할지 모르기때문. 따라서 Rc는 스레드 안전을 위한 성능 페널티를 원치 않는 싱글스레드 상황에서 사용되도록 구현

## Sync 마커 트레이트

- Sync가 구현된 타입이 여러 스레드로부터 안전하게 참조 가능함을 나타냄
- 만일 &T가 Send면, 즉 참조자가 다른 스레드로 안전하게 보내질 수 있다면 T는 Sync
- Rc는 같은 이유로 Sync하지 않음

# References

- 러스트 프로그래밍 공식 가이드 2판 (16장 겁없는 동시성)
